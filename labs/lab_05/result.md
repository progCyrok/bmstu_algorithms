<!-- #region editable=true slideshow={"slide_type": ""} -->
## Лабораторная работа № 5  (Хеш-таблицы и хеш-фукнции)
**Выполнил**: Камалов Ринат,  **Группа**: ИУ10-36
<!-- #endregion -->

### **Цель работы** 

Изучение хеш-функций и хеш-таблиц, а также основных операций над ними.

### **Словесная постановка задач** 



1. Реализовать хеш-таблицу на основе метода цепочек. (2 балла)

Суть задачи:  Реализовать структуру данных "хеш-таблица", использующую метод цепочек для разрешения коллизий.  Метод цепочек заключается в том, что при коллизии (когда разные ключи хешируются в одну и ту же ячейку таблицы) значения хранятся в виде связанного списка (или другой подходящей структуры данных) в этой ячейке.

Анализ входящих переменных:

• Ключи:  Входящие данные, которые используются для вычисления хеш-кода и определения позиции элемента в таблице. Тип ключей может быть произвольным (целые числа, строки, объекты и т.д.), но должен быть определен заранее.
• Значения: Данные, связанные с ключами.  Тип значений может быть произвольным.
• Размер таблицы:  Размер массива, используемого для хранения хеш-таблицы.  Выбор оптимального размера влияет на производительность.

Возможные ограничения:

• Размер памяти: Размер хеш-таблицы ограничен доступной памятью.
• Функция хеширования:  Качество функции хеширования влияет на количество коллизий и, следовательно, на производительность. Плохая функция хеширования может привести к деградации производительности до O(n) для поиска, вставки и удаления.
• Тип данных ключей и значений:  Необходимо учитывать ограничения, связанные с используемыми типами данных.


Анализ условий при которых задача имеет решение (не имеет решения):

Задача всегда имеет решение, при условии, что доступна достаточная память для хранения хеш-таблицы.  Невозможность решения может возникнуть только из-за ограничений ресурсов (памяти).

Анализ ожидаемых результатов:

Ожидается реализация класса или структуры данных, предоставляющей методы для добавления (insert), поиска (search/get), удаления (delete) элементов по ключу.  Методы должны работать с эффективностью O(1) в среднем случае и O(n) в худшем случае (при большом количестве коллизий).


2. Реализовать хеш-таблицу на основе открытой адресации. (2 балла)

Суть задачи:  Реализовать хеш-таблицу, использующую открытую адресацию для разрешения коллизий.  В открытой адресации, при коллизии, программа пытается найти следующую свободную ячейку в таблице, используя некоторую стратегию зондирования (например, линейное, квадратичное зондирование или двойное хеширование).

Анализ входящих переменных, возможные ограничения, условия решения и ожидаемые результаты:  Аналогичны задаче 1, за исключением того, что вместо связанных списков для хранения элементов используется сам массив хеш-таблицы.  Выбор стратегии зондирования влияет на производительность и может привести к кластеризации элементов.  Оптимальный размер таблицы и функция хеширования еще более критичны для открытой адресации.


3. Блокчейн (2 балла)

Суть задачи:  Реализовать упрощенную модель блокчейна.

Анализ входящих переменных:

• Данные:  Информация, которая будет храниться в блоках (например, транзакции).
• Функция хеширования:  Криптографическая хеш-функция (например, SHA-256).

Возможные ограничения:

• Выбор хеш-функции:  Выбор безопасной и эффективной хеш-функции.
• Упрощение модели:  Задача может быть упрощена путем игнорирования некоторых аспектов реальных блокчейнов (например, майнинга, консенсуса).

Анализ условий при которых задача имеет решение (не имеет решения):

Задача имеет решение, если доступна функция хеширования.  Ограничения могут возникнуть из-за сложности реализации полного блокчейна.

Анализ ожидаемых результатов:

Реализация должна позволять создавать новые блоки, содержащие хеш предыдущего блока и данные.  Реализация должна демонстрировать основные принципы блокчейна: неизменяемость данных (изменение одного блока приведет к изменению всех последующих хешей).


4. Проверка пересечения двух массивов (1 балл)

Суть задачи: Определить, есть ли хотя бы один общий элемент в двух массивах.

Анализ входящих переменных:

• Два массива (могут быть разных типов, но должны быть сравнимы на равенство).

Возможные ограничения:  Нет специфических ограничений.
цифических ограничений.

Анализ условий при которых задача имеет решение (не имеет решения): Задача всегда имеет решение.

Анализ ожидаемых результатов:  Функция, которая возвращает true, если массивы пересекаются, и false в противном случае.


5. Проверка уникальности элементов в массиве (1 балл)

Суть задачи:  Определить, содержатся ли в массиве только уникальные элементы.

Анализ входящих переменных:  Один массив (тип элементов должен позволять проверку на равенство).

Возможные ограничения: Нет специфических ограничений.

Анализ условий при которых задача имеет решение (не имеет решения): Задача всегда имеет решение.

Анализ ожидаемых результатов:  Функция, которая возвращает true, если все элементы массива уникальны, и false в противном случае.


6. Нахождение пар с заданной суммой (1 балл)

Суть задачи: Найти все пары чисел в массиве, сумма которых равна заданному целевому значению.

Анализ входящих переменных:

• Массив чисел.
• Целевое значение суммы.

Возможные ограничения:  Нет специфических ограничений.

Анализ условий при которых задача имеет решение (не имеет решения): Задача может не иметь решения, если в массиве нет пар чисел с заданной суммой.

Анализ ожидаемых результатов:  Список (или другой подходящий тип) пар чисел, сумма которых равна целевому значению.


7. Задача на проверку анаграмм (1 балл)

Суть задачи:  Определить, являются ли две строки анаграммами.

Анализ входящих переменных:  Две строки.

Возможные ограничения:  Регистр символов (нужно ли учитывать регистр или нет).  Пробелы и знаки препинания (нужно ли их игнорировать или учитывать).

Анализ условий при которых задача имеет решение (не имеет решения): Задача всегда имеет решение.

Анализ ожидаемых результатов:  Функция, которая возвращает true, если строки являются анаграммами, и false в противном случае.

#### **1. Реализовать хеш-таблицы на основе цепочки.**


```python
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value 
        self.next = None


class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [None] * size

    def hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        index = self.hash(key)
        new_node = Node(key, value)

        if self.table[index] is None:
            self.table[index] = new_node
        else:
            current = self.table[index]
            while current.next is not None:
                if current.key == key:
                    current.value = value
                    return
                current = current.next
            current.next = new_node

    def search(self, key):
        index = self.hash(key)
        current = self.table[index]
        while current is not None:
            if current.key == key:
                return current.value
            current = current.next
        return None

    def delete(self, key):
        index = self.hash(key)
        current = self.table[index]
        prev = None
        while current is not None:
            if current.key == key:
                if prev is None:
                    self.table[index] = current.next
                else:
                    prev.next = current.next
                return
            prev = current
            current = current.next

    def print_table(self):
        for index, node in enumerate(self.table):
            if node is not None:
                print(f"Index {index}: ", end='')
                current = node
                while current is not None:
                    print(f"({current.key}: {current.value})", end=' -> ')
                    current = current.next
                print("None")
            else:
                print(f"Index {index}: None")

hash_table = HashTable()

hash_table.insert("apple", 1)
hash_table.insert("banana", 2)
hash_table.insert("orange", 3)
hash_table.insert("grape", 4)

print("Содержимое хеш-таблицы:")
hash_table.print_table()

print("\nПоиск 'banana':", hash_table.search("banana"))

hash_table.delete("banana")
print("\nПосле удаления 'banana':")
hash_table.print_table()


```


#### **2. Реализовать хеш-таблицу на основе открытой адресации.**


```python
class HashTable:

    def __init__(self, size=10):
        self.size = size
        self.table = [None] * size
        self.deleted = object()

    def hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        index = self.hash(key)
        original_index = index

        while self.table[index] is not None and self.table[index] != self.deleted:
            if self.table[index][0] == key:
                self.table[index] = (key, value)
                return
            index = (index + 1) % self.size

            if index == original_index:
                raise Exception("Hash table is full")

        self.table[index] = (key, value)

    def search(self, key):

        index = self.hash(key)
        original_index = index

        while self.table[index] is not None:
            if self.table[index] != self.deleted and self.table[index][0] == key:
                return self.table[index][1]
            index = (index + 1) % self.size

            if index == original_index:
                break

        return None

    def delete(self, key):
        index = self.hash(key)
        original_index = index

        while self.table[index] is not None:
            if self.table[index] != self.deleted and self.table[index][0] == key:
                self.table[index] = self.deleted
                return
            index = (index + 1) % self.size

            if index == original_index:
                break

    def print_table(self):
        for index, item in enumerate(self.table):
            if item is None:
                print(f"Index {index}: None")
            elif item is self.deleted:
                print(f"Index {index}: Deleted")
            else:
                print(f"Index {index}: ({item[0]}: {item[1]})")


hash_table = HashTable()

hash_table.insert("apple", 1)
hash_table.insert("banana", 2)
hash_table.insert("orange", 3)
hash_table.insert("grape", 4)

print("Содержимое хеш-таблицы:")
hash_table.print_table()

print("\nПоиск 'banana':", hash_table.search("banana"))

hash_table.delete("banana")
print("\nПосле удаления 'banana':")
hash_table.print_table()

    
```


#### **3. Блокчейн (2 балла) В блокчейне хеш-функции используются для создания уникальных идентификаторов блоков и обеспечения целостности данных. Каждый блок содержит хеш предыдущего блока, что создает цепочку и делает систему устойчивой к изменениям.**


```python
import hashlib

class Block:
    def __init__(self, index, previous_hash, data, hash):
        self.index = index
        self.previous_hash = previous_hash
        self.data = data
        self.hash = hash

    def calculate_hash(index, previous_hash, data):
        value = str(index) + str(previous_hash) + str(data)
        return hashlib.sha256(value.encode()).hexdigest()

class Blockchain:
    def __init__(self):
        self.chain = []
        self.create_block(data="Genesis Block", previous_hash='0')

    def create_block(self, data, previous_hash=None):
        index = len(self.chain) + 1
        if previous_hash is None:
            previous_hash = self.chain[-1].hash if self.chain else '0'
        hash = Block.calculate_hash(index, previous_hash, data)
        new_block = Block(index, previous_hash, data, hash)
        self.chain.append(new_block)
        return new_block

    def get_chain(self):
        return self.chain

    def __str__(self):
        return "\n".join([
            f"Block {block.index}: [Hash: {block.hash}, Previous Hash: {block.previous_hash}, Data: {block.data}]"
            for block in self.chain
        ])

blockchain = Blockchain()
blockchain.create_block(data="Первый блок")
blockchain.create_block(data="Второй блок")
blockchain.create_block(data="Третий блок")

print(blockchain)


```



#### **4. Проверка пересечения двух массивов (1 балл)**


```python
def check(arr1, arr2):
    intersections = [value for value in arr1 if value in arr2]
    return intersections

array1 = [1, 2, 3, 4, 5, 7]
array2 = [4, 5, 6, 7, 8]
result = check(array1, array2)

if len(result) > 0:
    print(f"Пересечение найдено: {result}")
else:
    print("Пересечения нет.")

```

#### **5. Проверка уникальности элементов в массиве.**


```python
def check(arr):
    return len(arr) == len(set(arr))

array1 = [1, 2, 3, 4, 5]
array2 = [1, 2, 2, 3, 4]

print(check(array1))  # True
print(check(array2))  # False

```

#### **6. Нахождение пар с заданной суммой.**


```python
def find_pairs_with_sum(arr, target_sum):
    seen = set()
    pairs = []

    for number in arr:
        complement = target_sum - number

        if complement in seen:
            pairs.append((complement, number))

        seen.add(number)

    return pairs

numbers = [1, 2, 3, 4, 5, 6, 7, 8]
target = 10
result = find_pairs_with_sum(numbers, target)
print(f'Пары чисел с суммой {target}: {result}')

```


#### **7. Задача на проверку анаграмм.**


```python
def are_anagrams(str1, str2):
    return sorted(str1) == sorted(str2)

string1 = "BMSTU"
string2 = "BUTSM"
if are_anagrams(string1, string2):
    print(f'"{string1}" и "{string2}" являются анаграммами.')
else:
    print(f'"{string1}" и "{string2}" не являются анаграммами.')

```

---

# Контрольные вопросы по хешированию

## 1. Назначение хеширования

**Хеширование** — это процесс преобразования данных (например, строки, числа, объекта) в уникальный идентификатор фиксированной длины, называемый **хеш-значением** или **хеш-кодом**. Основное назначение хеширования:

- **Ускорение поиска данных**: Хеш-функции позволяют быстро искать, вставлять и удалять элементы в структуре данных (например, хеш-таблице), обеспечивая доступ к данным за время \( O(1) \) в среднем.
- **Проверка целостности данных**: Хеш-функции используются для создания контрольных сумм, позволяя проверить, были ли данные изменены.
- **Шифрование и безопасность**: Хеш-функции играют ключевую роль в алгоритмах криптографии, например, в цифровых подписях и хешировании паролей.

## 2. Способы реализации хеш-функций и хеш-таблиц

### Хеш-функции:
- **Математические хеш-функции**: Преобразуют данные в фиксированное значение с использованием математических операций (например, умножение, деление, битовые сдвиги).
  - Пример: `h(k) = k mod m`, где `k` — это ключ, а `m` — размер таблицы.
  
- **Криптографические хеш-функции**: Специально разработаны для обеспечения безопасности, такие хеш-функции устойчивы к коллизиям и труднообратимы.
  - Примеры: SHA-256, MD5.

- **Действие на строках**: Когда хешируемые данные — это строки, хеш-функции могут использовать сумму ASCII значений символов, умноженную на некоторые константы, или же более сложные методы.
  - Пример: Хеширование строк с использованием алгоритма, основанного на полиномиальной хеш-функции.

### Хеш-таблицы:
- **Простая хеш-таблица**: Массив с фиксированным размером, в котором хеш-коды элементов используются для определения их индексов.
  - При вставке элемента его хеш-код вычисляется и используется для индексации.
  - Преимущество: Быстрый доступ \( O(1) \), если нет коллизий.
  
- **Динамическая хеш-таблица**: Массив с возможностью изменения размера при увеличении количества элементов, что помогает избежать переполнения и улучшить производительность.

## 3. Понятие коллизии

**Коллизия** — это ситуация, когда два различных элемента (например, строки, числа) имеют одинаковое хеш-значение, то есть хеш-функция генерирует одинаковые индексы для разных входных данных. Коллизии могут возникать в любой хеш-таблице, так как пространство возможных хеш-кодов ограничено, а количество возможных данных — нет.

## 4. Варианты разрешения коллизий в хеш-таблице

Для решения коллизий существует несколько популярных методов:

### 1. Открытая адресация (Open Addressing)
При возникновении коллизии система поиска пытается найти следующий свободный слот в таблице для хранения элемента. Это достигается за счет различных стратегий поиска свободных мест:
- **Линейное пробирование**: Если возникает коллизия, проверяется следующий слот, и так до тех пор, пока не будет найден пустой.
- **Квадратичное пробирование**: Слоты проверяются с увеличением шага (например, 1, 4, 9, 16 и так далее).
- **Двойное хеширование**: Используется вторая хеш-функция для вычисления шага, по которому будет производиться поиск.

### 2. Цепочки (Chaining)
Вместо того чтобы искать свободный слот, для каждого индекса таблицы создается связанный список (или другая структура данных). Когда возникает коллизия, элементы, имеющие одинаковое хеш-значение, добавляются в этот список.
- Преимущество: Простота реализации и гибкость, так как количество элементов не ограничено размером хеш-таблицы.
- Недостаток: Время поиска может ухудшиться до \( O(N) \), если все элементы окажутся в одном списке.

### 3. Редиректирование или замена (Rehashing)
Этот метод заключается в том, что при возникновении коллизии хеш-таблица перераспределяет элементы по новой таблице, используя новую хеш-функцию или увеличивая размер таблицы. Это помогает уменьшить вероятность коллизий.

---
