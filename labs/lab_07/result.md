<!-- #region editable=true slideshow={"slide_type": ""} -->
## Лабораторная работа № 8  (Алгоритмы на графах)
***Выполнил***: Камалов Ринат,  ***Группа***: ИУ10-36
<!-- #endregion -->

### **Цель работы** 

Изучение основных алгоритмов на графах

### **Алгоритмы обхода графов.**

Существует множество алгоритмов на графах, в основе которых лежит систематический перебор вершин графа, причем такой, что каждая вершина
просматривается (посещается) в точности один раз. 
Поэтому важной задачей является нахождение «хороших»  методов такого перебора.
Под обходом графа (поиском на графе) мы будем понимать процесс систематического просмотра всех вершин графа с целью отыскания вершин,
удовлетворяющих некоторому условию.

**Обход (поиск) в глубину**.

Идея алгоритма: из текущей вершины движемся в первую вершину, смежную с текущей, в которой мы еще не были, если таковая есть. 
Если таковой нет, то возвращаемся в вершину, из которой мы попали в текущую. 
Если же таковой нет, и мы оказались в исходной вершине (возвращаться некуда), то это означает, что перебор вершин графа закончен.
Номера просмотренных вершин графа запоминаются в стеке.

**Обход (поиск) в ширину**.

Идея алгоритма: метод поиска в ширину получается из алгоритма поиска в глубину, если мы заменим стек возврата на очередь. 
Эта простая замена модифицирует порядок обхода вершин так, что обход идет равномерно во все стороны, а не вглубь как при поиске в глубину.


##### **Алгоритмы поиска на графе.**

**Нахождение эйлерова цикла**.

Определение: Если граф имеет цикл (не обязательно простой), содержащий все ребра графа по одному разу, то такой цикл называется эйлеровым циклом.
Идея алгоритма: начиная с произвольной вершины, строим путь, удаляя ребра и запоминая вершины в стеке, до тех пор, пока множество смежности очередной вершины не окажется пустым, что означает, что путь удлинить нельзя. 
Заметим, что при этом мы с необходимостью придем в ту вершину, с которой начали. 
В противном случае это означало бы, что вершина $v$ имеет нечетную степень, что невозможно по условию. 
Таким образом, из графа были удалены ребра цикла, а вершины цикла были сохранены в стеке $S$. 
Заметим, что при этом степени всех вершин остались четными. 
Далее вершина $v$ выводится в качестве первой вершины эйлерова цикла, а процесс продолжается, начиная с вершины, стоящей на вершине
стека.

**Нахождение гамильтонова цикла**.

Определение: Граф называется гамильтоновым, если в нем имеется цикл, содержащий каждую вершину этого графа. 
Сам цикл также называется гамильтоновым.

Идея алгоритма: в основе лежит перебор с возвратом (backtracking).
Начинаем поиск решения, например, с первой вершины графа. 
Предположим, что уже найдены первые $k$ компонент решения. 
Рассматриваем ребра, выходящие из последней вершины. 
Если есть такие рёбра, что идут в ранее не просмотренные вершины, то включаем эту вершину в решение и помечаем ее как
просмотренную. 
Получена ($k+1$) компонента решения. 
Если такой вершины нет, то возвращаемся к предыдущей вершине и пытаемся найти ребро, выходящее из нее в другую вершину. 
Решение получено при просмотре всех вершин графа и возможности достичь из последней первой вершины. 
Решение (цикл) выводится и продолжается процесс нахождения следующих циклов.

##### **Алгоритм нахождения кратчайших путей в графе.**

**Алгоритм Дейкстры**.

Определение: Дан простой взвешенный граф $G(V,E)$ без петель и дуг отрицательного веса. 
Найти кратчайшие пути от некоторой вершины a графа $G$ до всех остальных вершин этого графа.

Идея алгоритма: метка самой вершины $u$ полагается равной 0, метки остальных вершин — бесконечности. 
Это отражает то, что расстояния от $u$ до других вершин пока неизвестны.
Все вершины графа помечаются как непосещенные. 
Если все вершины посещены, алгоритм завершается. 
В противном случае из еще не посещенных вершин выбирается вершина $u$, имеющая минимальную метку. 
Мы рассматриваем всевозможные маршруты, в которых $u$ является предпоследним пунктом. 
Вершины, соединенные с вершиной $u$ ребрами, назовем соседями этой вершины. 
Для каждого соседа рассмотрим новую длину пути, равную сумме текущей метки $u$ и длины ребра, соединяющего $u$ с этим соседом. 
Если полученная длина меньше метки соседа, заменим метку этой длиной.
Рассмотрев всех соседей, пометим вершину $u$ как посещенную и повторим шаг.


### Задание №**1.**
#### Реализовать программу, выполняющую описанный набор операций на графах:

Требования:
 - граф должен быть реализован в виде класса;
 - каждая операция должна быть реализована как метод класса.

**Обход в глубину, Обход в ширину, Эйлерова цикл**
```python
from collections import deque

class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = []
        if v not in self.graph:
            self.graph[v] = []
        self.graph[u].append(v)
        self.graph[v].append(u)


    def dfs(self, start):
        visited = set()
        stack = []

        def dfs_util(node):
            visited.add(node)
            stack.append(node)
            for neighbor in self.graph.get(node, []):
                if neighbor not in visited:
                    dfs_util(neighbor)

        dfs_util(start)
        return stack

    def bfs(self, start):
        visited = set()
        queue = deque([start])

        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                visited.add(vertex)
                print(vertex, end=' ')

                for neighbor in self.graph[vertex]:
                    if neighbor not in visited:
                        queue.append(neighbor)

    def is_eulerian(self):
        for v in self.graph:
            if len(self.graph[v]) % 2 != 0:
                return False
        return True

    def find_euler_cycle(self):
        if not self.is_eulerian():
            return None

        temp_graph = {u: lst.copy() for u, lst in self.graph.items()}
        stack = []
        cycle = []

        start_vertex = next(iter(temp_graph))

        stack.append(start_vertex)

        while stack:
            u = stack[-1]

            if temp_graph[u]:
                v = temp_graph[u].pop()
                temp_graph[v].remove(u)
                stack.append(v)
            else:
                cycle.append(stack.pop())

        return cycle[::-1]




graph = Graph()
graph.add_edge(0, 1)
graph.add_edge(1, 2)
graph.add_edge(2, 3)
graph.add_edge(3, 0)
graph.add_edge(0, 4)

start_node = 1
print(f"Обход в глубину начиная с {start_node}:", graph.dfs(start_node))
print(f"Обход в ширину начиная с вершины {start_node}:", graph.bfs(start_node))
euler_cycle = graph.find_euler_cycle()

if euler_cycle:
    print("Эйлеров цикл найден:", euler_cycle)
else:
    print("Эйлеров цикл не существует.")

```
**Гамильтонова цикл**
```python
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.adj = [[] for _ in range(vertices)]

    def add_edge(self, u, v):
        self.adj[u].append(v)
        self.adj[v].append(u)

    def is_valid(self, v, pos, path):
        if self.adj[path[pos - 1]].count(v) == 0:
            return False

        if v in path:
            return False

        return True

    def hamiltonian_cycle_util(self, path, pos):
        if pos == self.V:
            if path[pos - 1] in self.adj[path[0]]:
                return True
            else:
                return False

        for v in range(1, self.V):
            if self.is_valid(v, pos, path):
                path[pos] = v

                if self.hamiltonian_cycle_util(path, pos + 1):
                    return True

                path[pos] = -1

        return False

    def hamiltonian_cycle(self):
        path = [-1] * self.V
        path[0] = 0

        if not self.hamiltonian_cycle_util(path, 1):
            print("Гамильтонова цикл не существует")
            return False

        self.print_solution(path)
        return True

    def print_solution(self, path):
        print("Найден гамильтонов цикл:")
        for i in range(len(path)):
            print(path[i], end=" ")
        print(path[0])


g = Graph(5)
g.add_edge(0, 1)
g.add_edge(0, 4)
g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(1, 4)
g.add_edge(2, 3)
g.add_edge(3, 4)

g.hamiltonian_cycle()

```

**Крачайший путь от вершины**
```python
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.adj = [[] for _ in range(vertices)]

    def add_edge(self, u, v):
        self.adj[u].append(v)
        self.adj[v].append(u)

    def is_valid(self, v, pos, path):
        if self.adj[path[pos - 1]].count(v) == 0:
            return False

        if v in path:
            return False

        return True

    def hamiltonian_cycle_util(self, path, pos):
        if pos == self.V:
            if path[pos - 1] in self.adj[path[0]]:
                return True
            else:
                return False

        for v in range(1, self.V):
            if self.is_valid(v, pos, path):
                path[pos] = v

                if self.hamiltonian_cycle_util(path, pos + 1):
                    return True

                path[pos] = -1

        return False

    def hamiltonian_cycle(self):
        path = [-1] * self.V
        path[0] = 0

        if not self.hamiltonian_cycle_util(path, 1):
            print("Гамильтонова цикл не существует")
            return False

        self.print_solution(path)
        return True

    def print_solution(self, path):
        print("Найден гамильтонов цикл:")
        for i in range(len(path)):
            print(path[i], end=" ")
        print(path[0])


g = Graph(5)
g.add_edge(0, 1)
g.add_edge(0, 4)
g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(1, 4)
g.add_edge(2, 3)
g.add_edge(3, 4)

g.hamiltonian_cycle()

```

### Задание №**2.**
#### Реализовать приложение, для работы с графом, которое реализует следующий набор действий:

 а) инициализация графа;

 б) организация диалогового цикла с пользователем;



```python
class Graph:
    def __init__(self):
        self.graph = {}

    def add_node(self, node):
        if node not in self.graph:
            self.graph[node] = []
            print(f"Узел {node} добавлен.")
        else:
            print(f"Узел {node} уже существует.")

    def add_edge(self, from_node, to_node):
        if from_node not in self.graph:
            print(f"Узел {from_node} не существует.")
            return
        if to_node not in self.graph:
            print(f"Узел {to_node} не существует.")
            return
        self.graph[from_node].append(to_node)
        print(f"Ребро добавлено: {from_node} -> {to_node}")

    def display_graph(self):
        if not self.graph:
            print("Граф пуст.")
        else:
            for node, edges in self.graph.items():
                print(f"{node}: {', '.join(edges)}")


def main():
    graph = Graph()

    while True:
        print("\n---- Меню ----")
        print("1. Добавить узел")
        print("2. Добавить ребро")
        print("3. Показать граф")
        print("4. Выход")

        choice = input("Выберите действие (1-4): ")

        if choice == '1':
            node = input("Введите имя узла: ")
            graph.add_node(node)
        elif choice == '2':
            from_node = input("Введите имя начального узла: ")
            to_node = input("Введите имя конечного узла: ")
            graph.add_edge(from_node, to_node)
        elif choice == '3':
            graph.display_graph()
        elif choice == '4':
            print("Выход из программы.")
            break
        else:
            print("Неверный ввод, попробуйте снова.")


main()


```

### Задание №**3.1.**
#### Найти кратчайший путь на графе между парами вершин ориентированного графа.

```python
import heapq

def dijkstra(graph, start, end):
    distances = {vertex: float('inf') for vertex in graph}
    distances[start] = 0
    previous_vertices = {vertex: None for vertex in graph}
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        if current_distance > distances[current_vertex]:
            continue

        if current_vertex == end:
            path = []
            while current_vertex is not None:
                path.insert(0, current_vertex)
                current_vertex = previous_vertices[current_vertex]
            return distances[end], path

        for neighbor, weight in graph[current_vertex]:
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous_vertices[neighbor] = current_vertex
                heapq.heappush(priority_queue, (distance, neighbor))

    return None

graph = {
    1: [(2, 8), (5, 11)],
    2: [(3, 15), (6, 9)],
    3: [(4, 2), (7, 1)],
    4: [(7, 6)],
    5: [(2, 3), (3, 11), (6, 10)],
    6: [(4, 1), (7, 3)],
    7: []
}

result = dijkstra(graph, 5, 7)

if result:
    distance, path = result
    print(f"Кратчайший путь от 5 до 7: {path}")
    print(f"Длина пути: {distance}")
else:
    print("Путь от 5 до 7 не существует.")




```



### Задание №**3.2.**
#### Реализовать алгоритм Дейкстры поиска кратчайшего пути на графе между парами вершин:


```python
import heapq

def dijkstra(graph, start, goal):
    distances = {vertex: float('inf') for vertex in graph}
    distances[start] = 0
    predecessors = {}
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        if current_distance > distances[current_vertex]:
            continue

        if current_vertex == goal:
            path = []
            while current_vertex is not None:
                path.insert(0, current_vertex)
                current_vertex = predecessors.get(current_vertex)
            return distances[goal], path

        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_vertex
                heapq.heappush(priority_queue, (distance, neighbor))

    return float('inf'), []

graph = {
    1: {2: 1, 3: 13, 4: 6, 6: 11, 7: 15},
    2: {1: 1, 3: 5, 4: 5, 5: 1},
    3: {1: 13, 2: 5, 8: 19},
    4: {1: 6, 2: 5, 5: 3, 6: 2},
    5: {2: 1, 4: 3, 6: 8, 8: 12},
    6: {1: 11, 4: 2, 5: 8, 7: 3},
    7: {1: 15, 6: 3, 8: 1},
    8: {3: 19, 5: 12, 7: 1}
}

start_node = 7
end_node = 3

distance, path = dijkstra(graph, start_node, end_node)

if distance == float('inf'):
    print(f"Пути между вершинами {start_node} и {end_node} нет.")
else:
    print(f"Кратчайший путь между вершинами {start_node} и {end_node}: {path}")
    print(f"Длина кратчайшего пути: {distance}")


```

### **Контрольные вопросы**

##### 1. Что такое граф? Что такое ребро и дуга графа?

**Граф** — это математическая структура, состоящая из множества вершин (или узлов) и набора рёбер (или дуг), соединяющих пары вершин. Граф может быть представлен как \( G = (V, E) \), где \( V \) — множество вершин, а \( E \) — множество рёбер.

- **Ребро** — это связь между двумя вершинами в неориентированном графе.
- **Дуга** — это связь между двумя вершинами в ориентированном графе, где важен порядок (направление) соединения.

##### 2. Что такое ориентированный граф и неориентированный граф?

- **Ориентированный граф** — граф, в котором рёбра имеют направление. Это означает, что каждое ребро ведёт от одной вершины к другой, и порядок важен. Например, если есть дуга от вершины A к вершине B, это не означает, что есть дуга от B к A.

- **Неориентированный граф** — граф, в котором рёбра не имеют направления. Ребро соединяет две вершины и не указывает, в каком направлении происходит соединение. Если есть ребро между A и B, это подразумевает наличие двусторонней связи.

##### 3. Какие вершины называют смежными? Какие ребра называют смежными? Что означает слово инцидентные?

- **Смежные вершины** — это вершины, соединенные общим ребром (или дугой). В неориентированном графе, если между двумя вершинами есть ребро, они считаются смежными.

- **Смежные рёбра** (или дуги) — это рёбра, которые имеют общую вершину.

- **Инцидентные** — слово используется для описания связи между вершиной и рёбером. Вершина инцидентна ребру, если это ребро соединяет данную вершину с другой.

##### 4. Что такое вес вершины, вес ребра?

- **Вес ребра** — это числовая величина, которая может представлять стоимость, длину или любую другую метрику, ассоциирующуюся с переходом или связью между двумя вершинами. Веса могут быть как положительными, так и отрицательными.

- **Вес вершины** — это аналогично весу ребра, но применяется к самой вершине. Вершины могут иметь ассоциированные значения, которые могут использоваться в различных алгоритмах, но не так широко, как веса рёбер.

##### 5. Какие способы представления графов существуют?

Существует несколько способов представления графов:

1. **Список смежности**: В каждой вершине хранится список соседних вершин. Это эффективный способ для разреженных графов.
   
2. **Матрица смежности**: Двумерный массив, где элемент [i][j] равен 1 (или весу ребра), если существует ребро между вершинами i и j, и 0 в противном случае. Этот вариант менее эффективен для разреженных графов.

3. **Список рёбер**: Список пар вершин, где каждая пара представляет собой ребро. Это также подходит для хранения графов, но менее компактно, чем список смежности.

##### 6. В чем разница между алгоритмами поиска в ширину и поиска в глубину?

- **Поиск в ширину (BFS)**:
  - Исследует вершины графа по уровням. Начинает с корневой (или стартовой) вершины и рассматривает все её соседние вершины, а затем переходит к соседям соседей, и так далее.
  - Использует очередь для хранения вершин для последующего обхода.
  - Хорош для нахождения кратчайшего пути в неориентированном графе.

- **Поиск в глубину (DFS)**:
  - Исследует граф, углубляясь в каждую ветвь до тех пор, пока не достигнет дна (или не встретит безвыходность), а затем возвращается и проверяет другие ветви.
  - Использует стек (или подразумевает рекурсию) для хранения вершин.
  - Может не находить кратчайший путь.

##### 7. Описать алгоритм нахождения кратчайшего пути.

Одним из популярных алгоритмов нахождения кратчайшего пути является алгоритм Дейкстры:

1. **Инициализация**: Установите дистанцию от начальной вершины до самой себя равной 0, а до всех остальных вершин — бесконечность. Поместите все вершины в очередь с приоритетом (или обычную очередь).

2. **Обработка**: Пока очередь не пуста:
   - Извлеките из очереди вершину с наименьшей дистанцией.
   - Для каждой смежной вершины:
     - Вычислите полную стоимость пути к смежной вершине (дистанция к текущей вершине + вес ребра).
     - Если новая полная стоимость меньше текущей известной стоимости, обновите её и обновите очередь.

3. **Завершение**: Программа завершает работу, когда все вершины обработаны, или позже, если минимальное расстояние до цели найдено.

##### 8. Описать алгоритмы нахождения эйлерова и гамильтонова цикла.

- **Эйлеров цикл**:
  - Это цикл, который проходит через каждое ребро графа ровно один раз и возвращается в начальную вершину. 
  - Для неориентированного графа эйлеров цикл существует, если все вершины имеют четный степень; для ориентированного графа — если все вершины имеют одинаковое количество входящих и исходящих рёбер.
  - Алгоритм: можно использовать метод Флёри, который подразумевает выбор рёбер поэтапно, следуя определённым правилам, и избегая создания изолированных рёбер.

- **Гамильтонов цикл**:
  - Это цикл, который проходит через каждую вершину графа ровно один раз и возвращается в начальную вершину.
  - Намного сложнее найти, поскольку это NP-полная задача. Не существует общего алгоритма, эффективного для всех типов графов.
  - Подходы включают поиск в глубину с возвратом (backtracking) и динамическое программирование, но они могут быть вычислительно затратными для больших графов.

